 // No es requerido en el esquema si no siempre se usa para todos los usuarios.
        // Si no se proporciona email, el usuario no tendr√° una contrase√±a para login.
        // Podr√≠amos hacer que sea requerido, pero su valor podr√≠a ser un hash de un string vac√≠o si no hay email.
        // Para simplificar, lo haremos requerido, y si no hay email, generamos una contrase√±a ficticia (o manejamos que no tenga login por pass).
        // PERO, PARA TU CASO (SI HAY EMAIL, ENTONCES HAY PASS):
        // Haremos que 'password' sea requerido SIEMPRE, pero su valor se generar√° si hay email,
        // o se dejar√° como un hash de un string temporal si no hay email y el login es solo por tel√©fono.
        // --- Para tu requerimiento de "si email, entonces pass":

// En un proyecto real, la contrase√±a debe ser hasheada en el Modelo antes de guardar

All core backend logic for user authentication, authorization, and basic CRUD operations is now complete! üéâ

The next steps involve testing the API endpoints and setting up the frontend to interact with them.

Here is a roadmap for moving forward:

1. Environment Setup
Before testing, ensure your environment variables are configured in a .env file at the root of your project:

Variable	Example Value	Used in	Purpose
PORT	5000	server.js	The port your Express server runs on.
MONGO_URI	mongodb+srv://user:pass@cluster.mongodb.net/dbname	config/db.js	Your MongoDB connection string.
JWT_SECRET	A_VERY_LONG_RANDOM_STRING_HERE_FOR_SECURITY	authMiddleware.js, generateToken.js	Crucial for signing and verifying JSON Web Tokens.
EMAIL_USER	youremail@gmail.com	emailConfig.js	Email address used for sending registration emails.
EMAIL_PASS	your_app_password	emailConfig.js	App password (if using Gmail/OAuth) for sending emails.

Exportar a Hojas de c√°lculo

2. API Testing (Postman/Insomnia)
Use a tool like Postman or Insomnia to confirm every endpoint works as expected:

A. Public Routes (Testing Registration and Login)
Register a Client (Public):

POST /api/users/register

Body: { firstName: "Jane", email: "jane@test.com", phone: "1234567890", address: "123 St" }

Result: User created, temp password emailed.

Login (Public):

POST /api/users/login

Body: { email: "jane@test.com", password: "the_temp_password" }

Result: Get a JWT token. Save this token for the next steps.

B. Protected Routes (Testing protect Middleware)
Get Profile (Protected):

GET /api/users/profile

Header: Authorization: Bearer <JWT_from_login>

Result: 200 OK with Jane's user data. (If you omit the header, you should get a 401 Unauthorized).

C. Admin Routes (Testing admin Middleware)
Admin Creation (Admin Setup):

Manually create an Admin user in your MongoDB database (or create a temporary admin registration endpoint) so you can get an Admin JWT.

Test Admin Route (adminTest):

GET /api/users/admin-test

Header: Authorization: Bearer <JWT_from_Jane_Client>

Result: 403 Forbidden (Jane is not an Admin).

Header: Authorization: Bearer <JWT_from_Admin_User>

Result: 200 OK with "Welcome Admin!" message.

Create New User (createUser):

POST /api/users/create

Header: Authorization: Bearer <JWT_from_Admin_User>

Body: { firstName: "Cleaner", email: "cleaner@app.com", phone: "9876543210", password: "securepassword", role: "cleaner" }

Result: 201 Created with the new user's details.

3. Frontend Development
The next major step is building the client application (e.g., using React) that consumes these APIs.

Key Frontend Components:
Login/Register Forms: Send user data to /api/users/login and /api/users/register.

Authentication Context/Store: A central mechanism (like React Context or Redux) to store the JWT and the authenticated user object (ID, name, role).

Protected Routes: Implement logic that redirects users to the login page if they try to access a page (like /profile or /admin/dashboard) without a valid JWT stored in the browser.

API Service: A service (e.g., using Axios) to automatically attach the stored JWT to the Authorization header for all requests to protected endpoints.

Testing the endpoints is your most immediate and important step to ensure the backend logic is solid before starting the frontend development.